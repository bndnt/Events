import { useState, useEffect } from "react";

const ButtonClicks = () => {
  const [clicks, setClicks] = useState(0);

  const handleClick = () => {
    setClicks(clicks + 1);
  };
  useEffect(() => {
    document.title = `Clicked ${clicks} times`;
  });
  // Хук useEffect не повертає жодного значення як результат своєї роботи, а лише запускає виконання анонімної функції. Іншими словами, неможливо виконати в середині функції обчислення і повернути їх у зовнішній код. Ефекти не призначені для цього!
  // useEffect(() => {
  //   // ...
  // }, []);

  return (
    <>
      <button onClick={handleClick}>Current: {clicks}</button>
    </>
  );
};
export default ButtonClicks;

// Реактивність

// Давайте розглянемо приклад використання звичайної змінної для відображення кількості кліків по кнопці. Кожне натискання на кнопку повинно змінити значення змінної і відобразити нове значення в інтерфейсі. Проте це не працюватиме, ви можете спробувати!

// const App = () => {
// 	let clicks = 0;

//   const handleClick = () => {
//     clicks = clicks + 1;
//   };

// 	return <button onClick={handleClick}>Current: {clicks}</button>
// };

// Обробник подій handleClick оновлює локальну змінну clicks. Проте дві речі заважають змінам бути видимими:

//     Локальні змінні не зберігаються між рендерами. Коли React рендерить цей компонент вдруге, він рендерить його з нуля — не враховує жодних змін у локальних змінних.
//     Зміни локальних змінних не викликають повторних рендерів. React не усвідомлює необхідності повторного рендерингу компонента з новими даними.

// Для оновлення компонента новими даними потрібно виконати дві речі:

//     Зберегти дані між рендерами.
//     Заставити React рендерити компонент з новими даними (повторний рендеринг).

// Перепишемо код з використанням стану. Щоб додати змінну стану, імпортуйте useState з React угорі файлу компонента.

// import { useState } from 'react';

// const App = () => {
// 	let clicks = 0;

//   const handleClick = () => {
//     clicks = clicks + 1;
//   };

// 	return <button onClick={handleClick}>Current: {clicks}</button>
// };

// Далі замінимо локальну змінну clicks.

// import { useState } from 'react';

// const App = () => {
// 	// let clicks = 0;
// 	const [ clicks, setClicks ] = useState(0);

//   const handleClick = () => {
//     clicks = clicks + 1;
//   };

// 	return <button onClick={handleClick}>Current: {clicks}</button>
// };

// Тут синтаксис [ clicks, setClicks ] - це деструктуризація масиву. Масив, який повертає useState, завжди має точно два елементи: перший (clicks) - це змінна стану, а другий (setClicks) - це функція для її встановлення.

// У handleClick використовуємо setClicks для зміни стану clicks.

// import { useState } from 'react';

// const App = () => {
// 	const [ clicks, setClicks ] = useState(0);

//   const handleClick = () => {
//     // clicks = clicks + 1;
// 		setClicks(clicks + 1);
//   };

// 	return <button onClick={handleClick}>Current: {clicks}</button>
// };

// Тепер, при кліку на кнопку, стан в змінній clicks буде змінюватися, що змусить компонент оновлюватися і повторно рендерити JSX з оновленими значеннями.

// Хук useState
// Хук useState
// Хук useState
// Хук useState
// Хук useState
// Хук useState

// Функція useState, так само, як і будь-яка інша функція, що починається з use, називається хуком.
// Хуки - це просто спеціальні функції, за допомогою яких можна "підключитися" до різних можливостей React.
// Стан - це лише одна з їх можливостей, але ви зустрінете інші хуки пізніше.
// Якщо ви бажаєте використовувати хук, імпортуйте його в файлі компонента з бібліотеки React.
// Коли ви викликаєте useState, ви повідомляєте React, що бажаєте, щоб цей компонент запам'ятовував щось. У цьому випадку ми хочемо, щоб React запам'ятовував clicks.

{
  /*Єдиним аргументом для useState є початкове значення змінної стану. У цьому прикладі початкове значення clicks встановлено на 0 за допомогою useState(0)


Кожного разу, коли компонент рендериться, useState повертає масив, що містить два значення:

    Змінну стану (clicks) зі збереженим поточним значенням.
    Функцію встановлення стану(setClicks), яка може оновлювати змінну стану і викликати повторний рендеринг компонента.
    Використовуючи деструктуризацію, можна задати будь-які імена змінних. Рекомендовано називати цю пару як [something, setSomething]. Ви можете називати їх будь-як, але конвенції полегшують розуміння коду в різних проектах.
Декілька станів

Ви можете мати стільки змінних стану, скільки потрібно в одному компоненті. Для кожного використовуйте окремий useState.


const [a, setA] = useState();
const [b, setB] = useState();
const [c, setC] = useState();*/
}
