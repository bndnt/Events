import { useState } from "react";
import reactLogo from "./assets/react.svg";
import viteLogo from "/vite.svg";
import "./App.css";

import ButtonClicks from "./components/States/ButtonClicks";

// function App() {
//   // const handleClick = () => {
//   //   alert("Congrats!!");
//   // };
//   const handleClick = (evt) => {
//     console.log(evt);
//   };
//   return (
//     <>
//       <button onClick={handleClick}>first!</button>
//       <button onClick={(evt) => console.log(evt)}>second!</button>
//     </>
//   );
// }

//React дозволяє додавати обробники подій до вашого JSX. Обробники подій - це власні функції, які будуть викликані відповідно до взаємодій, таких як клікання, наведення, фокусування на полях введення форм і таке інше.

// Використання addEventListener() для додавання обробника подій майже ніколи не використовується в React,
// окрім кількох винятків, які ми розглянемо окремо.
// Щоб додати обробник подій до JSX-елементу, потрібно передати йому проп, який описує тип події.
// Значенням пропа повинно бути посилання на функцію зворотного виклику, яка буде викликана при настанні події.

// Ми об'явили функцію handleClick і потім передали її як проп для <button>.

//     Пропи подій визначаються в React та мають ім'я в стилі camelCase, починаючи з префікса on, після чого йде назва події. Наприклад: onClick, onSubmit, onChange, і так далі.
//     Функції обробників подій, такі як handleClick, визначаються всередині компонентів.
//     За конвенцією ім'я обробника подій починається з handle, за яким слідує назва події. Ви часто побачите щось на зразок onClick={handleClick}, onSubmit={handleSubmit}, і так далі.

// Також можна визначити обробник подій безпосередньо всередині JSX як анонімну інлайн-функцію.

// Оскільки обробники подій оголошуються всередині компонента, вони мають доступ до пропсів компонента. Ось приклад компонента кнопки CustomButton, яка, коли на неї натискано, виводить alert зі значенням пропса message:

// const CustomButton = ({ message, children }) => {
//   return <button onClick={() => alert(message)}>{children}</button>;
// };

// const App = () => {
//   return (
//     <>
//       <CustomButton message="Playing music!">Play some music</CustomButton>
//       <CustomButton message="Uploading your data!">Upload data</CustomButton>
//     </>
//   );
// };

// export default App;

// Стан компонента
// Стан компонента
// Стан компонента
// Стан компонента
// Стан компонента
// Стан компонента
// Стан компонента
// Стан компонента

// Компонентам часто потрібно змінювати те, що відображається на екрані внаслідок
// взаємодії з користувачем. Введення даних в форму повинно оновлювати поле вводу,
//  клікання в слайдері зображень повинно змінювати зображення, натискання "купити"
// повинно додавати товар у кошик.

// Компонентам потрібно "запам'ятовувати" різні речі: поточне значення введення,
// поточне зображення, кошик покупок. У React такий вид пам'яті, що специфічний
// для компонента, називається станом (state). Пропси (props) - це дані, які передаються
// компоненту ззовні, а стан (state) - це його внутрішні динамічні дані.

// const App = () => {
//   let clicks = 0;

//   const handleClick = () => {
//     clicks = clicks + 1;
//   };

//   return <button onClick={handleClick}> Clicks:{clicks}</button>;
// };

// Обробник подій handleClick оновлює локальну змінну clicks. Проте дві речі заважають змінам бути видимими:
//     Локальні змінні не зберігаються між рендерами. Коли React рендерить цей компонент вдруге, він рендерить його з нуля — не враховує жодних змін у локальних змінних.
//     Зміни локальних змінних не викликають повторних рендерів. React не усвідомлює необхідності повторного рендерингу компонента з новими даними.

// Для оновлення компонента новими даними потрібно виконати дві речі:
//     Зберегти дані між рендерами.
//     Заставити React рендерити компонент з новими даними (повторний рендеринг).

// Перепишемо код з використанням стану. Щоб додати змінну стану, імпортуйте useState з React угорі файлу компонента.

const App = () => {
  return <ButtonClicks />;
};
export default App;
